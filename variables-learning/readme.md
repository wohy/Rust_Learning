# rust 变量学习

## 基础变量赋值声明
1. rust 中的变量默认不可变,需要在声明变量时，加上 mut 修饰
2. rust 如果变量已声明但未使用， rust 编译器将报出警告，声明未使用变量时，变量命名要使用 _ 开头
```rs
let a = 1
let mut b = 2 // 可变变量
let _c = 3  // 可不使用变量
```

## 解构赋值
```rs
let (a, mut b) = (1, 2)
let (e, f, g, h, i);
g = 3;
// .. 表示匹配中间部分 多位，  _ 表示 匹配某一位
// 执行后 h 赋值为 4， i 赋值为 5
[h, .., i, _, _] = [4, 1, 2, 3, 6, 5, 7, 8];
// 执行后 e 值为 1
FirstStruct { e, f, .. } = FirstStruct { e: 1, f: 2, j: 3, k: 4 };
assert_eq!([e, f, g, h, i], [1, 2, 3, 4, 5]);
println!("断言成功e, f, g, h, i的值分别对应1, 2, 3, 4, 5");
```

## 常量声明
```rs
const MAX_POINTS: u32 = 100_000;
println!("常量 MAX_POINTS 的值为 {}", MAX_POINTS)
```

# 数值类型
## 整数
整数是没有小数部分的数字。
- 例如 i32 类型，表示有符号的 32 位整数（其中 i 是英文单词 integer 的首字母，与之相反的是 u，代表无符号 unsigned 类型）
包括了 8、16、32、64、128 位
以及 isize、usize 类型，取决于程序运行的计算机 CPU 类型： 若 CPU 是 32 位的，则这两个类型是 32 位的，同理，若 CPU 是 64 位，那么它们则是 64 位
- 有符号类型
每个有符号类型规定的数字范围是 -(2**(n - 1)) ~ (2**(n - 1)) - 1，其中 n 是该定义形式的位长度。
- 无符号位类型
无符号类型可以存储的数字范围是 0 ~ （2**n） - 1

因此例如 i8 可存储数字范围是 -(2**7) ~ （2**7） - 1，即 -128 ~ 127。 u8 能够存储的数字为 0 ~ 28 - 1，即 0 ~ 255。 依此类推

### 整型溢出
- 概念：
假设有一个 u8 ，它可以存放从 0 到 255 的值。那么当你将其修改为范围之外的值，比如 256，则会发生整型溢出。
- 分别在 debug 模式 和 release 模式下的不通表现
    - debug 模式
    Rust 会检查整型溢出，若存在这些问题，则使程序在编译时 panic(崩溃,Rust 使用这个术语来表明程序因错误而退出)
    - release 模式
    release 模式构建时，Rust 不检测溢出。相反，当检测到整型溢出时，Rust 会按照补码循环溢出（two’s complement wrapping）的规则处理。简而言之，大于该类型最大值的数值会被补码转换成该类型能够支持的对应数字的最小值。比如在 u8 的情况下，256 变成 0，257 变成 1


## 浮点类型
浮点类型数字 是带有小数点的数字，在 Rust 中浮点类型数字也有两种基本类型： f32 和 f64，分别为 32 位和 64 位大小。默认浮点类型是 f64，在现代的 CPU 中它的速度与 f32 几乎相同，但精度更高。
```rs
let x = 2.0; // f64
let y: f32 = 3.0; // f32
```
浮点数根据 IEEE-754 标准实现。f32 类型是单精度浮点型，f64 为双精度。

### 浮点数陷阱
1. 浮点数往往是你想要数字的近似表达 浮点数类型是基于二进制实现的，但是我们想要计算的数字往往是基于十进制。浮点数计算时需要注意
2. 浮点数在某些特性上是反直觉的。进行浮点数比较时，需要注意。因为 f32 ， f64 上的比较运算实现的是 std::cmp::PartialEq 特征(类似其他语言的接口)，但是并没有实现 std::cmp::Eq 特征，但是后者在其它数值类型上都有定义

- 例如 无法使用浮点数作为 HashMap 的 Key
Rust 的 HashMap 数据结构，是一个 KV 类型的 Hash Map 实现，它对于 K 没有特定类型的限制，但是要求能用作 K 的类型必须实现了 std::cmp::Eq 特征，因此这意味着你无法使用浮点数作为 HashMap 的 Key，来存储键值对，但是作为对比，Rust 的整数类型、字符串类型、布尔类型都实现了该特征，因此可以作为 HashMap 的 Key。

- 避免陷阱的原则：
    - 避免在浮点数上测试相等性
    - 当结果在数学上可能存在未定义时，需要格外的小心

## NaN
对于数学上未定义的结果
- **注意**
所有跟 NaN 交互的操作，都会返回一个 NaN，而且 NaN 不能用来比较，下面的代码会崩溃
- is_nan() 等方法，可以用来判断一个数值是否是 NaN

## char
单引号
Rust 的字符不仅仅是 ASCII，所有的 Unicode 值都可以作为 Rust 字符，包括单个的中文、日文、韩文、emoji 表情符号等等，都是合法的字符类型
```rs
let x = '中';
// 字符'中'占用了4字节的内存大小
println!("字符'中'占用了{}字节的内存大小",std::mem::size_of_val(&x));
```

## bool
true  flase

## 单元类型
单元类型就是 ``()``
- 例如
main 函数就返回这个单元类型 ()
println!() 的返回值也是单元类型 ()

永不返回的函数，单独被定义为 **发散函数**

## 语句和表达式
语句：执行  无返回值
表达式：返回一个内容

## 函数
- 要点
    - 函数名和变量名使用蛇形命名法(snake case)，例如 fn add_two() -> {}
    - 函数的位置可以随便放，Rust 不关心我们在哪里定义了函数，只要有定义即可
    - 每个函数参数都需要标注类型
- 例如
```rs
fn add(i: i32, j: i32) -> i32 {
   i + j
}
```
### 无返回值 返回 单元类型 ()
() 零长度的元组。它没啥作用，但是可以用来表达一个函数没有返回值
- 例如, 下面的 report 函数会隐式返回一个 ()
```rs
use std::fmt::Debug;
fn report<T: Debug>(item: T) {
  println!("{:?}", item);
}
```

### 永不返回的 发散函数 !
当用 ! 作函数返回类型的时候，表示该函数永不返回( diverge function )，特别的，这种语法往往用做会导致程序崩溃的函数
- 例如
```rs
// 崩溃
fn dead_end() -> ! {
  panic!("你已经到了穷途末路，崩溃吧！");
}
// 死循环
fn forever() -> ! {
  loop {
    //...
  };
}
```