# rust 数据类型学习

在 Rust 中，类型可以分为基本类型（也称为原始类型或简单类型）和复杂类型（也称为复合类型或高级类型）。以下是一些常见的分类：

## 基本类型（Primitive Types）：

1. **标量类型**（Scalar Types）:
   - 整数类型：`i8`, `i16`, `i32`, `i64`, `i128`, `isize`
   - 无符号整数类型：`u8`, `u16`, `u32`, `u64`, `u128`, `usize`
   - 浮点类型：`f32`, `f64`
   - 布尔类型：`bool`（值为 `true` 或 `false`）
   - 字符类型：`char`（Unicode 标量值）

2. **复合类型**（Compound Types）:
   - 元组（`(T0, T1, ...)`）：包含固定数量的不同类型的值。
   - 数组（`[T; N]`）：包含固定数量 `N` 的相同类型 `T` 的元素。

3. **空类型**（Void Type）:
   - `!`：表示没有值的类型，通常用于表示不返回任何值的函数。

## 复杂类型（Complex Types 或 Composite Types）：
1. **字符串类型**：
   - `String`：可增长的、可变的 UTF-8 字符串。
   - `&str`：字符串切片，对字符串的不可变引用。

2. **枚举类型**（`enum`）：
   - 用户定义的类型，可以是多种可能的值之一。

3. **结构体**（`struct`）：
   - 用户定义的类型，可以包含多个字段，这些字段可以是不同的类型。

4. **联合体**（`union`）：
   - 类似于 C/C++ 中的联合体，允许在相同的内存位置存储不同的数据类型。

5. **智能指针**：
   - `Box<T>`：指向堆上数据的所有权指针。
   - `Rc<T>`：引用计数智能指针，允许多个所有者。
   - `Arc<T>`：线程安全的 `Rc<T>`。
   - `RefCell<T>` 和 `Cow<T>`：运行时借用检查的智能指针。

6. **函数指针**：
   - 指向函数的指针。

7. **闭包**：
   - 匿名函数或表达式，可以捕获和使用外部环境中的变量。

8. **切片**（Slice）：
   - 引用一段连续的序列，例如数组或字符串的一部分。

9. **选项和结果类型**：
   - `Option<T>`：可以是 `Some(T)` 或 `None`。
   - `Result<T, E>`：可以是 `Ok(T)` 或 `Err(E)`，用于表示操作可能成功或失败。

10. **迭代器**：
    - 能够对集合进行遍历的对象。

11. **Trait 对象**：
    - 类似于 C++ 中的虚函数表，允许动态分派。

12. **动态大小类型**（Dynamically Sized Types，DST）：
    - 类型的大小在编译时不固定，例如 `str` 和 `[T]`。

## 集合类型
### Vector 动态数组
#### 声明方式
- 1. Vec::new()
   ```rs
   let mut vec_demo: Vec<i32> = Vec::new()
   ```
   其中 i32 可以也可以是结构体类型，也可以无需标注类型，会根据 push 时传入的内容类型进行推断

   如果已知数组长度，可以声明为 ``Vec::with_capacity(capacity)``创建动态数组，这样可以避免因为插入大量新数据导致频繁的内存分配和拷贝，提升性能

- 2. vec![]
   ```rs
   let v = vec![1, 2, 3];
   ```
   使用 宏的方式创建 在创建同时给予初始化值， 可以无需标注类型，rust 会自动推断


Vector 类型在超出作用域范围后，会被自动删除

## String 和 &str
Rust 中的字符是 Unicode 类型，因此每个字符占据 4 个字节内存空间，但是在字符串中不一样，字符串是 UTF-8 编码，也就是字符串中的字符所占的字节数是变化的(1 - 4)

- String 字符串
字符串的底层的数据存储格式实际上是[ u8 ]，一个字节数组。
每个字母在 UTF-8 编码中仅占用 1 个字节
大部分常用汉字在 UTF-8 中的长度是 3 个字节

### String 和 &str 的区别
在 Rust 中，`&str` 和 `String` 是处理文本数据的两种不同的类型，它们在内存管理和使用方式上有着重要的区别：

1. **内存管理**:
   - `&str`：是一个字符串切片（string slice），它是对某个字符串字面量或 `String` 类型实例的一部分的引用。它不拥有其引用的字符串数据，因此不需要负责释放内存。
   - `String`：是一个可增长、可变、拥有分配在堆上的内存的 UTF-8 字符串。`String` 类型拥有其数据，当 `String` 实例被销毁时，其内存也会被释放。

2. **可变性**:
   - `&str`：是不可变的，一旦创建，你不能修改引用的字符串内容。
   - `String`：是可变的，你可以修改 `String` 实例中的字符。

3. **长度**:
   - `&str`：通常表示为一个字符串切片，不包含字符串的完整长度，只表示字符串的一部分。
   - `String`：具有明确的长度，可以通过 `.len()` 方法获取。

4. **创建方式**:
   - `&str`：可以从字符串字面量或通过借用 `String` 实例创建。
   - `String`：可以通过多种方式创建，例如使用 `String::new()` 构造函数或 `to_string()` 方法将 `&str` 转换为 `String`。

5. **用途**:
   - `&str`：适用于访问和借用现有的字符串数据，不需要修改字符串内容。
   - `String`：适用于需要修改字符串内容的场景，例如拼接字符串、修改字符串中的字符等。

6. **性能**:
   - `&str`：因为是对现有数据的引用，所以使用 `&str` 通常更轻量级，没有额外的内存分配开销。
   - `String`：可能涉及堆分配，创建 `String` 实例可能比借用字符串有更高的性能成本。

7. **方法可用性**:
   - `&str`：可以使用许多方法来访问字符串数据，例如 `.chars()`、`.as_bytes()` 等，但不能使用修改字符串的方法。
   - `String`：可以使用所有 `str` 方法以及修改字符串的方法，如 `.push_str()`、`.clear()` 等。

### 转换:
   - 可以从 `String` 实例中借用数据创建 `&str`，也可以通过 `.to_string()` 方法将 `&str` 转换为 `String`。
   ```rs
    // String -> &str
    let s = String::from("hello world");
    let hello = &s[0..5];
    let world = &s[6..11];
    let hello1 = ·s[..5];
    let world1 = &s[6..];
    let all = &s[..];
    let s_str = s.as_str();
    // &str -> String
    let the_string_s1 = String::from("hello world");
    let the_string_s2 = "hello,world".to_string()
   ```

### 注意
使用切片语法时需要格外小心，切片的索引必须落在字符之间的边界位置，也就是 UTF-8 字符的边界，例如中文在 UTF-8 中占用三个字节
```rs
let s = "中国人";
// 将报错，最少切出 中 字都需要  3 个字节
// let a = &s[0..2];
let a = &s[0..3];
println!("{}",a);
```

### 字符操作
#### 添加 push/push_str
在原有的字符串上追加，并不会返回新的字符串
字符串变量必须由 mut 关键字修饰
#### 插入 insert/insert_str
字符串插入操作要修改原来的字符串，则该字符串必须是可变的，即字符串变量必须由 mut 关键字修饰。

#### 替换 replace/replacen/replace_range
这四个方法仅适用于 String 类型
- replace
方法是返回一个新的字符串，而不是操作原来的字符串。
该方法可适用于 String 和 &str 类型
- replacen
该方法可适用于 String 和 &str 类型。replacen() 方法接收三个参数，前两个参数与 replace() 方法一样，第三个参数则表示匹配到多个时替换的个数。
方法是返回一个新的字符串，而不是操作原来的字符串。
该方法可适用于 String 和 &str 类型
- replace_range
该方法是直接操作原来的字符串，不会返回新的字符串。该方法需要使用 mut 关键字修饰
该方法仅适用于 String 类型
#### 删除 pop/remove/truncate/clear
方法是直接操作原来的字符串
- pop
删除并返回字符串的最后一个字符
其返回值是一个 Option 类型，如果字符串为空，则返回 None
- remove
删除并返回字符串中指定位置的字符
其返回值是删除位置的字符串，只接收一个参数，表示该字符起始索引位置
按照字节来处理字符串的，如果参数所给的位置不是合法的字符边界，则会发生错误
- truncate
删除字符串中从指定位置开始到结尾的全部字符
无返回值。该方法 truncate() 方法是按照字节来处理字符串的，如果参数所给的位置不是合法的字符边界，则会发生错误。
- clear
调用后，删除字符串中的所有字符，相当于 truncate() 方法参数为 0 的时候。

#### 连接
- 使用 + 或者 += 连接字符串
使用 + 或者 += 连接字符串，要求右边的参数必须为字符串的切片引用（Slice）类型。其实当调用 + 的操作符时，相当于调用了 std::string 标准库中的 add() 方法，这里 add() 方法的第二个参数是一个引用的类型。因此我们在使用 + 时， 必须传递切片引用类型。不能直接传递 String 类型。+ 是返回一个新的字符串，所以变量声明可以不需要 mut 关键字修饰。

- 使用 format! 连接字符串
format! 这种方式适用于 String 和 &str 。format! 的用法与 print! 的用法类似。



### 数组切片和字符串切片的工作方式是一样的

## 基础变量赋值声明
1. rust 中的变量默认不可变,需要在声明变量时，加上 mut 修饰
2. rust 如果变量已声明但未使用， rust 编译器将报出警告，声明未使用变量时，变量命名要使用 _ 开头
```rs
let a = 1
let mut b = 2 // 可变变量
let _c = 3  // 可不使用变量
```

## 解构赋值
```rs
let (a, mut b) = (1, 2)
let (e, f, g, h, i);
g = 3;
// .. 表示匹配中间部分 多位，  _ 表示 匹配某一位
// 执行后 h 赋值为 4， i 赋值为 5
[h, .., i, _, _] = [4, 1, 2, 3, 6, 5, 7, 8];
// 执行后 e 值为 1
FirstStruct { e, f, .. } = FirstStruct { e: 1, f: 2, j: 3, k: 4 };
assert_eq!([e, f, g, h, i], [1, 2, 3, 4, 5]);
println!("断言成功e, f, g, h, i的值分别对应1, 2, 3, 4, 5");
```

## 常量声明
```rs
const MAX_POINTS: u32 = 100_000;
println!("常量 MAX_POINTS 的值为 {}", MAX_POINTS)
```

# 基本类型详细
## 数值类型
### 整数
整数是没有小数部分的数字。
- 例如 i32 类型，表示有符号的 32 位整数（其中 i 是英文单词 integer 的首字母，与之相反的是 u，代表无符号 unsigned 类型）
包括了 8、16、32、64、128 位
以及 isize、usize 类型，取决于程序运行的计算机 CPU 类型： 若 CPU 是 32 位的，则这两个类型是 32 位的，同理，若 CPU 是 64 位，那么它们则是 64 位
- 有符号类型
每个有符号类型规定的数字范围是 -(2**(n - 1)) ~ (2**(n - 1)) - 1，其中 n 是该定义形式的位长度。
- 无符号位类型
无符号类型可以存储的数字范围是 0 ~ （2**n） - 1

因此例如 i8 可存储数字范围是 -(2**7) ~ （2**7） - 1，即 -128 ~ 127。 u8 能够存储的数字为 0 ~ 28 - 1，即 0 ~ 255。 依此类推

#### 整型溢出
- 概念：
假设有一个 u8 ，它可以存放从 0 到 255 的值。那么当你将其修改为范围之外的值，比如 256，则会发生整型溢出。
- 分别在 debug 模式 和 release 模式下的不通表现
    - debug 模式
    Rust 会检查整型溢出，若存在这些问题，则使程序在编译时 panic(崩溃,Rust 使用这个术语来表明程序因错误而退出)
    - release 模式
    release 模式构建时，Rust 不检测溢出。相反，当检测到整型溢出时，Rust 会按照补码循环溢出（two’s complement wrapping）的规则处理。简而言之，大于该类型最大值的数值会被补码转换成该类型能够支持的对应数字的最小值。比如在 u8 的情况下，256 变成 0，257 变成 1


### 浮点类型
浮点类型数字 是带有小数点的数字，在 Rust 中浮点类型数字也有两种基本类型： f32 和 f64，分别为 32 位和 64 位大小。默认浮点类型是 f64，在现代的 CPU 中它的速度与 f32 几乎相同，但精度更高。
```rs
let x = 2.0; // f64
let y: f32 = 3.0; // f32
```
浮点数根据 IEEE-754 标准实现。f32 类型是单精度浮点型，f64 为双精度。

#### 浮点数陷阱
1. 浮点数往往是你想要数字的近似表达 浮点数类型是基于二进制实现的，但是我们想要计算的数字往往是基于十进制。浮点数计算时需要注意
2. 浮点数在某些特性上是反直觉的。进行浮点数比较时，需要注意。因为 f32 ， f64 上的比较运算实现的是 std::cmp::PartialEq 特征(类似其他语言的接口)，但是并没有实现 std::cmp::Eq 特征，但是后者在其它数值类型上都有定义

- 例如 无法使用浮点数作为 HashMap 的 Key
Rust 的 HashMap 数据结构，是一个 KV 类型的 Hash Map 实现，它对于 K 没有特定类型的限制，但是要求能用作 K 的类型必须实现了 std::cmp::Eq 特征，因此这意味着你无法使用浮点数作为 HashMap 的 Key，来存储键值对，但是作为对比，Rust 的整数类型、字符串类型、布尔类型都实现了该特征，因此可以作为 HashMap 的 Key。

- 避免陷阱的原则：
    - 避免在浮点数上测试相等性
    - 当结果在数学上可能存在未定义时，需要格外的小心

## 序列(Range)
提供了一个非常简洁的方式，用来生成连续的数值
例如 1..5，生成从 1 到 4 的连续数字，不包含 5 ；1..=5，生成从 1 到 5 的连续数字，包含 5
```rs
for i in 1..=5 {
  // 打印 1 2 3 4 5
  println!("{}",i);
}
for i in 'a'..='z' {
  println!("{}",i);
}
```

## NaN
对于数学上未定义的结果
- **注意**
所有跟 NaN 交互的操作，都会返回一个 NaN，而且 NaN 不能用来比较，下面的代码会崩溃
- is_nan() 等方法，可以用来判断一个数值是否是 NaN

## char
单引号
Rust 的字符不仅仅是 ASCII，所有的 Unicode 值都可以作为 Rust 字符，包括单个的中文、日文、韩文、emoji 表情符号等等，都是合法的字符类型
```rs
let x = '中';
// 字符'中'占用了4字节的内存大小
println!("字符'中'占用了{}字节的内存大小",std::mem::size_of_val(&x));
```

## bool
true  flase

## 单元类型
单元类型就是 ``()``
- 例如
main 函数就返回这个单元类型 ()
println!() 的返回值也是单元类型 ()

永不返回的函数，单独被定义为 **发散函数**

# 语句和表达式
语句：执行  无返回值
表达式：返回一个内容

# 函数
- 要点
    - 函数名和变量名使用蛇形命名法(snake case)，例如 fn add_two() -> {}
    - 函数的位置可以随便放，Rust 不关心我们在哪里定义了函数，只要有定义即可
    - 每个函数参数都需要标注类型
- 例如
```rs
fn add(i: i32, j: i32) -> i32 {
   i + j
}
```
### 无返回值 返回 单元类型 ()
() 零长度的元组。它没啥作用，但是可以用来表达一个函数没有返回值
- 例如, 下面的 report 函数会隐式返回一个 ()
```rs
use std::fmt::Debug;
fn report<T: Debug>(item: T) {
  println!("{:?}", item);
}
```

### 永不返回的 发散函数 !
当用 ! 作函数返回类型的时候，表示该函数永不返回( diverge function )，特别的，这种语法往往用做会导致程序崩溃的函数
- 例如
```rs
// 崩溃
fn dead_end() -> ! {
  panic!("你已经到了穷途末路，崩溃吧！");
}
// 死循环
fn forever() -> ! {
  loop {
    //...
  };
}
```

# 堆栈存储
## 栈 
栈中的所有数据都必须占用已知且固定大小的内存空间，假设数据大小是未知的，那么在取出数据时，你将无法取到你想要的数据

## 堆
对于大小未知或者可能变化的数据，我们需要将它存储在堆上。
- 数据存储
堆首先需要请求一份内存空间，存入数据时，操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的指针（**allocating**）。指针将存储在栈中。下次访问直接通过指针地址访问对应元素

## 性能区别
栈的内存分配要快于堆
栈：直接入栈即可
堆：操作系统必须首先找到一块足够存放数据的内存空间，接着做一些记录为下一次分配做准备，如果当前进程分配的内存页不足时，还需要进行系统调用来申请更多内存

# 赋值、拷贝、所有权
## 所有权原则：
1. Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者
2. 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
3. 当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)

## 移动、所有权转移
- 所有权转移
当一个变量被赋值给另一个变量时，如果没有实现 **Copy trait**，所有权会从原始变量转移到新变量。
一旦所有权被移动，原始变量就不能再被使用，因为它不再拥有其值的所有权。

移动更具体地指的是值的所有权从一个变量转移到另一个变量

- 作用
避免数据竞争：移动确保同一时间只有一个变量可以拥有某个值的所有权，从而避免数据竞争。
自动释放：当拥有所有权的变量离开作用域时，它的值会自动被释放，除非所有权被转移给另一个变量。

### 函数相关
函数参数传递：当一个值以值传递的方式传递给函数时，如果没有实现 Copy trait，所有权会转移到函数内部。
返回值：函数返回一个值时，如果没有实现 Copy trait，所有权会从函数返回到调用者。

### 智能指针
对于智能指针（如 Box），移动操作会转移指针所指向的堆内存的所有权。

### 模式匹配
在模式匹配中解构结构体或元组时，如果没有为所有字段都实现 Copy trait，也会发生移动。


## Copy trait
在 Rust 中，实现了 **Copy trait** 的类型意味着它们的值在进行赋值操作或以值传递函数参数时，会被自动拷贝，而不是移动。
- 以下是 Rust 中实现了 **Copy trait** 的基本类型：
1. **所有整数类型**：
   - `i8`, `i16`, `i32`, `i64`, `i128`, `isize`
   - `u8`, `u16`, `u32`, `u64`, `u128`, `usize`

2. **布尔类型**：
   - `bool`（`true` 和 `false`）

3. **浮点类型**：
   - `f32`, `f64`

4. **字符类型**：
   - `char`

5. **元组**：
   - 如果元组中的所有元素类型都实现了 **Copy trait**，那么该元组类型也实现了 **Copy trait**。例如，`(i32, i32)` 实现了 `Copy`，但 `(i32, String)` 没有。

6. **数组**：
   - 固定长度的数组，如果数组中的所有元素类型都实现了 **Copy trait**，那么该数组类型也实现了 `Copy`。例如，`[i32; 5]` 实现了 `Copy`，但 `[T; N]` 没有，除非 `T` 实现了 `Copy`。

并非所有简单类型都实现了 **Copy trait**。例如，`&T`（引用）和 `&mut T`（可变引用）没有实现 `Copy`，因为它们不是简单的值类型。此外，`String` 和 `Vec<T>` 等复杂类型也没有实现 `Copy`，因为它们包含堆上的数据，拷贝这些类型意味着复制堆上的数据，这可能涉及到昂贵的内存分配和数据复制操作。

### 检查某个类型是否实现了 **Copy trait**
要检查某个类型是否实现了 **Copy trait**，你可以在 Rust Playground 或你的 Rust 环境中尝试实现该 trait，或者使用 IDE 的类型检查功能。如果类型已经实现了 `Copy`，编译器会允许你这样做；如果没有，编译器会报错。


## 深、浅拷贝
深拷贝：需要深度复制堆上的数据。例如， clone 方法

浅拷贝：发生在栈上

## 引用、借用
- 背景
直接转移所有权的方式进行获取变量值、赋值，会使程序复杂化。
以借用的方式，获取变量引用地址，去获取变量的值，会更简单

- 基本使用
```rs
let x = 5;
// &x 引用 x 地址
let y = &x;
assert_eq!(5, x);
// *y 解引用
assert_eq!(5, *y);
let s1 = String::from("hello");
// &s1 不可变引用。 应用不可变的情况下 可以使用 push_str 的方式去改变 String 的值
let a = &s1
let mut s2 = String::from("hello");
// &mut s2 可变引用
let b = &mut s2
// let c = &s2 // 无法同时借用 可变 和 不可变引用

// 悬垂指针
fn dangle() -> &String {
  let s = String::from("hello");
  &s
}
// 将直接报错
// this function's return type contains a borrowed value, but there is no value for it to be borrowed from.
// 该函数返回了一个借用的值，但是已经找不到它所借用值的来源
// s 是在 dangle 函数内创建的，当 dangle 的代码执行完毕后，s 将被释放，但是此时我们又尝试去返回它的引用。这意味着这个引用会指向一个无效的 String
// 应该直接返回 s 即可，而非 s 的引用

```
### 同一作用域，特定数据只能有一个可变引用

## 借用规则
1. 同一时刻，你只能拥有要么一个可变引用, 要么任意多个不可变引用
2. 引用必须总是有效的

