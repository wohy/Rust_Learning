fn main() {
    // let r;
    // {
    //     let x = 5;
    //     r = &x;
    // } // 这里 &x 的生命周期就结束了，所以为了运行时产生 悬空指针，编译将不通过
    // println!("r: {r}"); // 而此时 r 引用依旧指向 原 x 的地址， 可已为被释放的内存地址，这样就将造成悬空指针，rust 编译时将阻止这种行为

    // 显示声明生命周期 解决

    fn print_r<'a>() {
        let r;
        {
            let x:&'a i32 = &5; // x 的引用 生命周期将与 print_r 相同
            r = x
        }
        println!("r: {r}");
    }
    print_r(); // r: 5


    fn longest<'a>(x: &'a str, y: &'a str) -> &'a str { 
        // 表示两个参数和返回的引用存活的一样久。因为引用检查器并不知道我们将要返回 x 引用 还是 y 引用，也并不知道传入的 x 和 y 分别对应的生命周期，所以我们可以显示的声明其生命周期
        if x.len() > y.len() {
            x
        } else {
            y
        }
    }
    println!("{}", longest("123", "1234"));

}
