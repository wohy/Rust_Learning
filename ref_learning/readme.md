# 所有权、引用/借用、生命周期系统学习
## 名词概念
**所有权**：一个值只能被一个变量所拥有，且同一时刻只能有一个所有者，当所有者离开作用域，其拥有的值被丢弃，内存得到释放。
**Move 语义**：赋值或者传参会导致值 Move，所有权被转移，一旦所有权转移，之前的变量就不能访问。
**Copy 语义**：如果值实现了 Copy trait，那么赋值或传参会使用 Copy 语义，相应的值会被按位拷贝（浅拷贝），产生新的值。
**borrow 语义**：当没有实现 Copy trait ，但又不想发生所有权转移时，可以使用借用的方式

## 规则：
1. 一个值只能被一个变量所拥有，这个变量被称为所有者（Each value in Rust has a variable that’s called its owner）。
2. 一个值同一时刻只能有一个所有者（There can only be one owner at a time），也就是说不能有两个变量拥有相同的值。所以对应刚才说的变量赋值、参数传递、函数返回等行为，旧的所有者会把值的所有权转移给新的所有者，以便保证单一所有者的约束。
3. 当所有者离开作用域，其拥有的值被丢弃（When the owner goes out of scope, the value will be dropped），内存得到释放。

## 所有权转移后无法访问的问题
一些只存储在栈上的简单数据，如果要避免所有权转移之后不能访问的情况，我们就需要手动复制，会非常麻烦，效率也不高

- rust 提供的方案：
1. 如果你不希望值的所有权被转移，在 **Move** 语义外，Rust 提供了 **Copy** 语义。如果一个数据结构实现了 **Copy trait**，那么它就会使用 Copy 语义。这样，在你赋值或者传参时，值会自动按位拷贝（浅拷贝）。

2. 如果你不希望值的所有权被转移，又无法使用 Copy 语义，那你可以“借用”数据，我们下一讲会详细讨论“借用”。

## 实现了Copy trait 或者符合 Copy 语义
如果变量实现了Copy trait 或者符合 Copy 语义，则变量在 作为参数被传递 或者 赋值  时，将自动进行 浅拷贝
### 实现了 Copy 的类型：
原生类型，包括函数、不可变引用和裸指针实现了 Copy；
数组和元组，如果其内部的数据结构实现了 Copy，那么它们也实现了 Copy；

## 未实现Copy trait 或者不符合 Copy 语义
在赋值或者函数调用的时候无法 Copy，于是就按默认使用 Move 语义。而 Move 之后，所有权发生转移，原先的变量 data 无法访问
### 没有实现 Copy 的类型
可变引用没有实现 Copy；
非固定大小的数据结构，没有实现 Copy。

## 借用的生命周期及其约束
约束：借用不能超过值的生存期
- 在一个作用域内，仅允许一个活跃的可变引用。所谓活跃，就是真正被使用来修改数据的可变引用，如果只是定义了，却没有使用或者当作只读引用使用，不算活跃。

- 在一个作用域内，活跃的可变引用（写）和只读引用（读）是互斥的，不能同时存在。
例如：一个可变数组，向其中添加元素，保持不可变引用访问其元素。当堆上数据预留的内存空间不足时，数组将被拷贝到一块新的足够大内存中，原内存将释放，所以原可变引用将失效，导致出现内存问题

# 总结规则
一个值在同一时刻只有一个所有者。当所有者离开作用域，其拥有的值会被丢弃。
赋值或者传参会导致值 Move，所有权被转移，一旦所有权转移，之前的变量就不能访问。
如果值实现了 Copy trait，那么赋值或传参会使用 Copy 语义，相应的值会被按位拷贝，产生新的值。
一个值可以有多个只读引用。一个值可以有唯一一个活跃的可变引用。
可变引用（写）和只读引用（读）是互斥的关系，就像并发下数据的读写互斥那样。
引用的生命周期不能超出值的生命周期。

# 当运行时需要满足一个值拥有多个所有者时，应该怎么处理。且不与编译时，静态检查规则相违背
- 例如：
1. 一个有向无环图（DAG）中，某个节点可能有两个以上的节点指向它，这个按照所有权模型怎么表述？
2. 多个线程要访问同一块共享内存，怎么办？
## 使用 Rc（Reference counter 引用计数） 和 Arc（Atomic reference counter 智能指针）

### Rc
对一个 Rc 结构进行 clone()，不会将其内部的数据复制，只会增加引用计数。而当一个 Rc 结构离开作用域被 drop() 时，也只会减少其引用计数，直到引用计数为零，才会真正清除对应的内存。
```rs
use std::rc::Rc;
fn main() {
    let a = Rc::new(1);
    let b = a.clone();
    let c = a.clone();
    let d = b.clone(); // b 也可继续 clone ，引用计数继续加 1
}
```
其中 Rc 的 clone 函数实现如下：
```rs
fn clone(&self) -> Rc<T> {
    // 增加引用计数
    self.inner().inc_strong();
    // 通过 self.ptr 生成一个新的 Rc 结构
    Self::from_inner(self.ptr)
}
```

#### 实现一个有向无环图（DAG）


#### RefCell 对 Rc 进行可变引用
Rc 是一个只读的引用计数器，无法拿到 Rc 结构内部数据的可变引用，来修改这个数据
和 Rc 类似，RefCell 也绕过了 Rust 编译器的静态检查，允许我们在运行时，对某个只读数据进行可变借用

### Arc
Rc 的引用计数器不是线程安全的。当多线程访问同一块内存地址的值时，可以使用 Arc ，它实现了线程安全的引用计数器
- 引用计数器
Arc 内部使用了 Atomic usize 引用计数，而非普通的 usize ，它 usize 的原子类型，它使用了 cpu 的特殊指令来保证多线程下的安全

#### RefCell 也不是线程安全的
如果我们要在多线程中，使用内部可变性，Rust 提供了 Mutex 和 RwLock。
- Mutex 是互斥量，获得互斥量的线程对数据独占访问，
- RwLock 是读写锁，获得写锁的线程对数据独占访问，但当没有写锁的时候，允许有多个读锁。
读写锁的规则和 Rust 的借用规则非常类似

单线程中实现的有向无环图，需要在多线程中运用。需要将 ```Rc<RefCell<T>> ``` 替换为 ```Arc<Mutex<T>> ``` 或 ```Arc<RwLock<T>> ```

## 外部可变性 和 内部可变性
### 外部可变性
编译器可以在编译时进行严格地检查，保证只有可变的值或者可变的引用，才能修改值内部的数据，这被称作外部可变性（exterior mutability），外部可变性通过 mut 关键字声明
- 使用方式
let mut 或者 &mut
- 所有权检查
编译时检查，不符合规则，将产生编译错误


### 内部可变性
对并未声明为 mut 的值或者引用，在编译器的眼里，值是只读的，但是在运行时，这个值可以得到可变借用，从而修改内部的数据，这就是 RefCell 的用武之地。
- 使用方式
Cell 或 RefCell
- 所有权检查
运行时，不符合规则，将直接产生 panic


## Box
### Box::leak() 机制
创建不受栈内存控制的堆内存，从而绕开编译时的所有权规则

### Box
```Box``` 是 Rust 下的智能指针，它可以强制把任何数据结构创建在堆上，然后在栈上放一个指针指向这个数据结构，但此时堆内存的生命周期仍然是受控的，跟栈上的指针一致。
但 ```Box::leak()``` 它创建的对象，从堆内存上泄漏出去，不受栈内存控制，是一个自由的、生命周期可以大到和整个进程的生命周期一致的对象。

## 静态检查
静态检查，靠编译器保证代码符合所有权规则

## 动态检查
通过 Box::leak 让堆内存拥有不受限的生命周期，然后在运行过程中，通过对引用计数的检查，保证这样的堆内存最终会得到释放。

