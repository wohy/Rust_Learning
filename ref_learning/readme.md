# 所有权、引用/借用、生命周期系统学习
## 名词概念
**所有权**：一个值只能被一个变量所拥有，且同一时刻只能有一个所有者，当所有者离开作用域，其拥有的值被丢弃，内存得到释放。
**Move 语义**：赋值或者传参会导致值 Move，所有权被转移，一旦所有权转移，之前的变量就不能访问。
**Copy 语义**：如果值实现了 Copy trait，那么赋值或传参会使用 Copy 语义，相应的值会被按位拷贝（浅拷贝），产生新的值。
**borrow 语义**：当没有实现 Copy trait ，但又不想发生所有权转移时，可以使用借用的方式

## 规则：
1. 一个值只能被一个变量所拥有，这个变量被称为所有者（Each value in Rust has a variable that’s called its owner）。
2. 一个值同一时刻只能有一个所有者（There can only be one owner at a time），也就是说不能有两个变量拥有相同的值。所以对应刚才说的变量赋值、参数传递、函数返回等行为，旧的所有者会把值的所有权转移给新的所有者，以便保证单一所有者的约束。
3. 当所有者离开作用域，其拥有的值被丢弃（When the owner goes out of scope, the value will be dropped），内存得到释放。

## 所有权转移后无法访问的问题
一些只存储在栈上的简单数据，如果要避免所有权转移之后不能访问的情况，我们就需要手动复制，会非常麻烦，效率也不高

- rust 提供的方案：
1. 如果你不希望值的所有权被转移，在 **Move** 语义外，Rust 提供了 **Copy** 语义。如果一个数据结构实现了 **Copy trait**，那么它就会使用 Copy 语义。这样，在你赋值或者传参时，值会自动按位拷贝（浅拷贝）。

2. 如果你不希望值的所有权被转移，又无法使用 Copy 语义，那你可以“借用”数据，我们下一讲会详细讨论“借用”。

## 实现了Copy trait 或者符合 Copy 语义
如果变量实现了Copy trait 或者符合 Copy 语义，则变量在 作为参数被传递 或者 赋值  时，将自动进行 浅拷贝
### 实现了 Copy 的类型：
原生类型，包括函数、不可变引用和裸指针实现了 Copy；
数组和元组，如果其内部的数据结构实现了 Copy，那么它们也实现了 Copy；

## 未实现Copy trait 或者不符合 Copy 语义
在赋值或者函数调用的时候无法 Copy，于是就按默认使用 Move 语义。而 Move 之后，所有权发生转移，原先的变量 data 无法访问
### 没有实现 Copy 的类型
可变引用没有实现 Copy；
非固定大小的数据结构，没有实现 Copy。

