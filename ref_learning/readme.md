# 所有权、引用/借用、生命周期系统学习
## 名词概念
**所有权**：一个值只能被一个变量所拥有，且同一时刻只能有一个所有者，当所有者离开作用域，其拥有的值被丢弃，内存得到释放。
**Move 语义**：赋值或者传参会导致值 Move，所有权被转移，一旦所有权转移，之前的变量就不能访问。
**Copy 语义**：如果值实现了 Copy trait，那么赋值或传参会使用 Copy 语义，相应的值会被按位拷贝（浅拷贝），产生新的值。
**borrow 语义**：当没有实现 Copy trait ，但又不想发生所有权转移时，可以使用借用的方式

## 规则：
1. 一个值只能被一个变量所拥有，这个变量被称为所有者（Each value in Rust has a variable that’s called its owner）。
2. 一个值同一时刻只能有一个所有者（There can only be one owner at a time），也就是说不能有两个变量拥有相同的值。所以对应刚才说的变量赋值、参数传递、函数返回等行为，旧的所有者会把值的所有权转移给新的所有者，以便保证单一所有者的约束。
3. 当所有者离开作用域，其拥有的值被丢弃（When the owner goes out of scope, the value will be dropped），内存得到释放。

## 所有权转移后无法访问的问题
一些只存储在栈上的简单数据，如果要避免所有权转移之后不能访问的情况，我们就需要手动复制，会非常麻烦，效率也不高

- rust 提供的方案：
1. 如果你不希望值的所有权被转移，在 **Move** 语义外，Rust 提供了 **Copy** 语义。如果一个数据结构实现了 **Copy trait**，那么它就会使用 Copy 语义。这样，在你赋值或者传参时，值会自动按位拷贝（浅拷贝）。

2. 如果你不希望值的所有权被转移，又无法使用 Copy 语义，那你可以“借用”数据，我们下一讲会详细讨论“借用”。

## 实现了Copy trait 或者符合 Copy 语义
如果变量实现了Copy trait 或者符合 Copy 语义，则变量在 作为参数被传递 或者 赋值  时，将自动进行 浅拷贝
### 实现了 Copy 的类型：
原生类型，包括函数、不可变引用和裸指针实现了 Copy；
数组和元组，如果其内部的数据结构实现了 Copy，那么它们也实现了 Copy；

## 未实现Copy trait 或者不符合 Copy 语义
在赋值或者函数调用的时候无法 Copy，于是就按默认使用 Move 语义。而 Move 之后，所有权发生转移，原先的变量 data 无法访问
### 没有实现 Copy 的类型
可变引用没有实现 Copy；
非固定大小的数据结构，没有实现 Copy。

## 借用的生命周期及其约束
约束：借用不能超过值的生存期
- 在一个作用域内，仅允许一个活跃的可变引用。所谓活跃，就是真正被使用来修改数据的可变引用，如果只是定义了，却没有使用或者当作只读引用使用，不算活跃。

- 在一个作用域内，活跃的可变引用（写）和只读引用（读）是互斥的，不能同时存在。
例如：一个可变数组，向其中添加元素，保持不可变引用访问其元素。当堆上数据预留的内存空间不足时，数组将被拷贝到一块新的足够大内存中，原内存将释放，所以原可变引用将失效，导致出现内存问题

# 总结规则
一个值在同一时刻只有一个所有者。当所有者离开作用域，其拥有的值会被丢弃。
赋值或者传参会导致值 Move，所有权被转移，一旦所有权转移，之前的变量就不能访问。
如果值实现了 Copy trait，那么赋值或传参会使用 Copy 语义，相应的值会被按位拷贝，产生新的值。
一个值可以有多个只读引用。一个值可以有唯一一个活跃的可变引用。
可变引用（写）和只读引用（读）是互斥的关系，就像并发下数据的读写互斥那样。
引用的生命周期不能超出值的生命周期。

# 当运行时需要满足一个值拥有多个所有者时，应该怎么处理。且不与编译时，静态检查规则相违背
- 例如：
1. 一个有向无环图（DAG）中，某个节点可能有两个以上的节点指向它，这个按照所有权模型怎么表述？
2. 多个线程要访问同一块共享内存，怎么办？
## 使用 Rc（Reference counter 引用计数） 和 Arc（Atomic reference counter 智能指针）
### Rc
对一个 Rc 结构进行 clone()，不会将其内部的数据复制，只会增加引用计数。而当一个 Rc 结构离开作用域被 drop() 时，也只会减少其引用计数，直到引用计数为零，才会真正清除对应的内存。
```rs
use std::rc::Rc;
fn main() {
    let a = Rc::new(1);
    let b = a.clone();
    let c = a.clone();
}
```
其中 Rc 的 clone 函数实现如下：
```rs
fn clone(&self) -> Rc<T> {
    // 增加引用计数
    self.inner().inc_strong();
    // 通过 self.ptr 生成一个新的 Rc 结构
    Self::from_inner(self.ptr)
}
```

### Box::leak() 机制
创建不受栈内存控制的堆内存，从而绕开编译时的所有权规则
Box 是 Rust 下的智能指针，它可以强制把任何数据结构创建在堆上，然后在栈上放一个指针指向这个数据结构，但此时堆内存的生命周期仍然是受控的，跟栈上的指针一致。

### 动态检查
通过 Box::leak 让堆内存拥有不受限的生命周期，然后在运行过程中，通过对引用计数的检查，保证这样的堆内存最终会得到释放。